<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>File4YouTube</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
--bg:#0b0e14;--card:#131720;--card2:#1a1f2e;--border:#252d3a;
--text:#d4dce8;--text2:#7a8599;--accent:#4da6ff;--accent2:#2563eb;
--success:#34d399;--danger:#f87171;--warning:#fbbf24;
--radius:12px;--font:'Segoe UI',system-ui,-apple-system,sans-serif;
}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:var(--font);line-height:1.5}
a{color:var(--accent);text-decoration:none}
.wrap{max-width:780px;margin:0 auto;padding:24px 20px 60px}
.header{text-align:center;padding:40px 0 32px}
.header h1{font-size:28px;font-weight:700;letter-spacing:-0.5px;background:linear-gradient(135deg,var(--accent),var(--success));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.header p{color:var(--text2);font-size:14px;margin-top:8px;max-width:500px;margin-left:auto;margin-right:auto}
.tabs{display:flex;gap:4px;background:var(--card);border-radius:var(--radius);padding:4px;margin-bottom:24px}
.tab{flex:1;padding:12px;text-align:center;border-radius:8px;cursor:pointer;font-weight:600;font-size:14px;color:var(--text2);transition:all .2s;border:none;background:none}
.tab.active{background:var(--accent2);color:#fff}
.tab:hover:not(.active){color:var(--text);background:var(--card2)}
.section{display:none}
.section.active{display:block}
.card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:24px;margin-bottom:16px}
.drop-zone{border:2px dashed var(--border);border-radius:var(--radius);padding:48px 24px;text-align:center;cursor:pointer;transition:all .25s}
.drop-zone:hover,.drop-zone.drag{border-color:var(--accent);background:rgba(77,166,255,.06)}
.drop-zone .icon{font-size:40px;margin-bottom:12px;opacity:.5}
.drop-zone .label{font-size:15px;font-weight:600;color:var(--text)}
.drop-zone .sub{font-size:13px;color:var(--text2);margin-top:4px}
.file-info{display:flex;align-items:center;gap:12px;padding:14px 16px;background:var(--card2);border-radius:8px;margin-top:16px}
.file-info .fi-icon{width:40px;height:40px;border-radius:8px;background:var(--accent2);display:flex;align-items:center;justify-content:center;font-size:18px;flex-shrink:0}
.file-info .fi-details{flex:1;min-width:0}
.file-info .fi-name{font-size:14px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.file-info .fi-size{font-size:12px;color:var(--text2)}
.file-info .fi-remove{width:32px;height:32px;border:none;background:none;color:var(--text2);cursor:pointer;font-size:18px;border-radius:6px;display:flex;align-items:center;justify-content:center}
.file-info .fi-remove:hover{background:rgba(248,113,113,.15);color:var(--danger)}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:14px 28px;border:none;border-radius:8px;font-size:15px;font-weight:600;cursor:pointer;transition:all .2s;width:100%}
.btn-primary{background:var(--accent2);color:#fff}
.btn-primary:hover:not(:disabled){background:#3b82f6}
.btn-primary:disabled{opacity:.4;cursor:not-allowed}
.btn-success{background:#059669;color:#fff}
.btn-success:hover{background:#047857}
.btn-cancel{background:var(--danger);color:#fff;margin-top:8px}
.btn-cancel:hover{background:#ef4444}
.progress-wrap{margin-top:16px;display:none}
.progress-wrap.show{display:block}
.progress-bar-bg{height:8px;background:var(--card2);border-radius:4px;overflow:hidden}
.progress-bar{height:100%;background:linear-gradient(90deg,var(--accent2),var(--accent));border-radius:4px;width:0%;transition:width .3s}
.progress-text{display:flex;justify-content:space-between;margin-top:8px;font-size:12px;color:var(--text2)}
.status{margin-top:16px;padding:14px 16px;border-radius:8px;font-size:13px;display:none;align-items:flex-start;gap:10px;line-height:1.5}
.status.show{display:flex}
.status.info{background:rgba(77,166,255,.1);border:1px solid rgba(77,166,255,.2);color:var(--accent)}
.status.ok{background:rgba(52,211,153,.1);border:1px solid rgba(52,211,153,.2);color:var(--success)}
.status.err{background:rgba(248,113,113,.1);border:1px solid rgba(248,113,113,.2);color:var(--danger)}
.status.warn{background:rgba(251,191,36,.1);border:1px solid rgba(251,191,36,.2);color:var(--warning)}
.status .s-icon{font-size:16px;flex-shrink:0;margin-top:1px}
.dl-area{margin-top:16px;display:none}
.dl-area.show{display:block}
.hash-box{margin-top:12px;padding:12px;background:var(--card2);border-radius:8px;font-family:'Courier New',monospace;font-size:11px;word-break:break-all;color:var(--text2)}
.hash-label{font-size:11px;color:var(--text2);margin-bottom:4px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
.verify-result{margin-top:12px;padding:12px 16px;border-radius:8px;font-size:14px;font-weight:600;display:none}
.verify-result.show{display:block}
.verify-result.pass{background:rgba(52,211,153,.12);color:var(--success);border:1px solid rgba(52,211,153,.2)}
.verify-result.fail{background:rgba(248,113,113,.12);color:var(--danger);border:1px solid rgba(248,113,113,.2)}
.specs{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:16px}
.spec{padding:10px 12px;background:var(--card2);border-radius:8px;font-size:12px}
.spec .spec-label{color:var(--text2);font-size:11px}
.spec .spec-value{font-weight:600;margin-top:2px}
.compat-warn{padding:20px;background:rgba(248,113,113,.1);border:1px solid rgba(248,113,113,.25);border-radius:var(--radius);color:var(--danger);text-align:center;margin-bottom:24px;font-size:14px}
.compat-warn strong{display:block;font-size:16px;margin-bottom:4px}

.quality-card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-bottom:16px}
.quality-card .q-title{font-size:14px;font-weight:600;margin-bottom:12px;color:var(--text)}
.quality-options{display:flex;gap:8px}
.quality-opt{flex:1;padding:14px 10px;background:var(--card2);border:2px solid var(--border);border-radius:10px;cursor:pointer;text-align:center;transition:all .2s;user-select:none}
.quality-opt:hover{border-color:var(--accent)}
.quality-opt.active{border-color:var(--accent2);background:rgba(37,99,235,.12)}
.quality-opt .q-icon{font-size:18px;margin-bottom:4px;display:block}
.quality-opt .q-label{font-size:13px;font-weight:700;display:block}
.quality-opt .q-desc{font-size:10px;color:var(--text2);margin-top:4px;display:block;line-height:1.3}
.quality-opt .q-bitrate{font-size:10px;color:var(--accent);margin-top:3px;display:block;font-weight:600}

.est-info{margin-top:12px;padding:10px 14px;background:var(--card2);border-radius:8px;font-size:13px;color:var(--text2);display:none}
.est-info.show{display:flex;align-items:center;gap:8px}
.est-info .est-icon{font-size:14px;flex-shrink:0}
.est-info .est-val{color:var(--accent);font-weight:600}

.size-warn{margin-top:8px;padding:10px 14px;background:rgba(251,191,36,.1);border:1px solid rgba(251,191,36,.2);border-radius:8px;font-size:12px;color:var(--warning);display:none}
.size-warn.show{display:block}

.footer-social{display:flex;justify-content:center;gap:16px;padding:32px 0 16px}
.social-link{width:40px;height:40px;border-radius:50%;background:var(--card2);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;color:var(--text2);transition:all .2s}
.social-link:hover{background:var(--accent2);border-color:var(--accent2);color:#fff}
.social-link svg{width:20px;height:20px;fill:currentColor}

@media(max-width:600px){
.wrap{padding:16px 12px 40px}
.header{padding:24px 0 20px}
.header h1{font-size:22px}
.card{padding:16px}
.drop-zone{padding:32px 16px}
.specs{grid-template-columns:1fr}
.quality-options{flex-direction:column}
.quality-opt{padding:12px 14px;display:flex;align-items:center;gap:12px;text-align:left}
.quality-opt .q-icon{margin-bottom:0;font-size:16px}
.quality-opt .q-right{flex:1}
}
</style>
</head>
<body>
<div class="wrap">
<div class="header">
<h1>File4YouTube</h1>
<p>encode any file into a real video</p>
</div>

<div id="compatWarn" class="compat-warn" style="display:none">
<strong>Browser Not Supported</strong>
<span>This tool requires WebCodecs API</span>
</div>

<div class="tabs">
<div class="tab active" data-tab="encode">Encode File</div>
<div class="tab" data-tab="decode">Decode Video</div>
</div>

<!-- ENCODE -->
<div id="encodeSection" class="section active">
<div class="card">
<div id="encDropZone" class="drop-zone">
<div class="icon">&#128196;</div>
<div class="label">Drop file here</div>
<div class="sub">Any file type supported</div>
</div>
<input type="file" id="encFileInput" style="display:none">
<div id="encFileInfo" class="file-info" style="display:none">
<div class="fi-icon">&#128196;</div>
<div class="fi-details">
<div id="encFileName" class="fi-name"></div>
<div id="encFileSize" class="fi-size"></div>
</div>
<button id="encRemoveBtn" class="fi-remove" title="Remove">&times;</button>
</div>
</div>

<div class="quality-card">
<div class="q-title">Video Quality</div>
<div class="quality-options">
<div class="quality-opt active" data-quality="youtube">
<span class="q-icon">&#9650;</span>
<span class="q-label">YouTube</span>
<span class="q-desc">Max reliability</span>
<span class="q-bitrate">8 Mbps</span>
</div>
<div class="quality-opt" data-quality="balanced">
<span class="q-icon">&#9644;</span>
<span class="q-label">Balanced</span>
<span class="q-desc">Good quality</span>
<span class="q-bitrate">4 Mbps</span>
</div>
<div class="quality-opt" data-quality="compact">
<span class="q-icon">&#9660;</span>
<span class="q-label">Compact</span>
<span class="q-desc">Smallest files</span>
<span class="q-bitrate">1.5 Mbps</span>
</div>
</div>
<div id="estInfo" class="est-info">
<span class="est-icon">&#8505;</span>
<span id="estText"></span>
</div>
<div id="sizeWarn" class="size-warn"></div>
</div>

<button id="encodeBtn" class="btn btn-primary" disabled>File to Video</button>
<button id="encCancelBtn" class="btn btn-cancel" style="display:none">Cancel</button>

<div id="encProgress" class="progress-wrap">
<div class="progress-bar-bg"><div id="encBar" class="progress-bar"></div></div>
<div class="progress-text"><span id="encPercent">0%</span><span id="encStatus">Preparing...</span></div>
</div>

<div id="encStatusMsg" class="status"></div>

<div id="encSpecs" class="specs" style="display:none">
<div class="spec"><div class="spec-label">Resolution</div><div id="specRes" class="spec-value">1280 x 720</div></div>
<div class="spec"><div class="spec-label">Codec</div><div class="spec-value">H.264 (AVC)</div></div>
<div class="spec"><div class="spec-label">Block Size</div><div id="specBlocks" class="spec-value">16x16 px</div></div>
<div class="spec"><div class="spec-label">Frames</div><div id="specFrames" class="spec-value">&mdash;</div></div>
<div class="spec"><div class="spec-label">Data Rate</div><div id="specDataRate" class="spec-value">900 bytes/frame</div></div>
<div class="spec"><div class="spec-label">Bitrate</div><div id="specBitrate" class="spec-value">8 Mbps</div></div>
</div>

<div id="encHashArea" style="display:none">
<div class="hash-label">SHA-256 Checksum</div>
<div id="encHash" class="hash-box"></div>
</div>

<div id="encDlArea" class="dl-area">
<button id="encDlBtn" class="btn btn-success">Download Video</button>
</div>
</div>

<!-- DECODE -->
<div id="decodeSection" class="section">
<div class="card">
<div id="decDropZone" class="drop-zone">
<div class="icon">&#127916;</div>
<div class="label">Drop video here</div>
<div class="sub">MP4/WebM video encoded by this tool</div>
</div>
<input type="file" id="decFileInput" accept="video/*" style="display:none">
<div id="decFileInfo" class="file-info" style="display:none">
<div class="fi-icon">&#127916;</div>
<div class="fi-details">
<div id="decFileName" class="fi-name"></div>
<div id="decFileSize" class="fi-size"></div>
</div>
<button id="decRemoveBtn" class="fi-remove" title="Remove">&times;</button>
</div>
</div>

<button id="decodeBtn" class="btn btn-primary" disabled>Video to File</button>
<button id="decCancelBtn" class="btn btn-cancel" style="display:none">Cancel Decoding</button>

<div id="decProgress" class="progress-wrap">
<div class="progress-bar-bg"><div id="decBar" class="progress-bar"></div></div>
<div class="progress-text"><span id="decPercent">0%</span><span id="decStatus">Preparing...</span></div>
</div>

<div id="decStatusMsg" class="status"></div>

<div id="decVerify" class="verify-result"></div>

<div id="decHashArea" style="display:none">
<div class="hash-label">Expected SHA-256</div>
<div id="decHashExpected" class="hash-box"></div>
<div class="hash-label" style="margin-top:8px">Actual SHA-256</div>
<div id="decHashActual" class="hash-box"></div>
</div>

<div id="decDlArea" class="dl-area">
<button id="decDlBtn" class="btn btn-success">Download Extracted File</button>
</div>
</div>

<div class="footer-social">
<a href="https://github.com/tooter9" target="_blank" rel="noopener" class="social-link" title="GitHub">
<svg viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61-.546-1.385-1.335-1.755-1.335-1.755-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 21.795 24 17.295 24 12c0-6.63-5.37-12-12-12z"/></svg>
</a>
<a href="https://x.com/elonmusk" target="_blank" rel="noopener" class="social-link" title="X (Twitter)">
<svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
</a>
</div>
</div>

<script type="module">
import { Muxer, ArrayBufferTarget } from 'https://cdn.jsdelivr.net/npm/mp4-muxer@5/+esm';

const W = 1280, H = 720, BS = 16, FPS = 30;
const COLS = W / BS, ROWS = H / BS, BPF = COLS * ROWS;
const BYTES_PER_FRAME = BPF / 4;
const COLORS = [[0,0,0],[255,0,0],[0,255,0],[0,0,255]];
const COLORS_U32 = new Uint32Array([0xFF000000, 0xFF0000FF, 0xFF00FF00, 0xFFFF0000]);
const MAGIC = [0x46,0x32,0x56,0x31];
const MIN_DURATION_SEC = 3;
const MIN_FRAMES = MIN_DURATION_SEC * FPS;

const QUALITY = {
  youtube:  { bitrate: 8_000_000, label: 'YouTube Safe' },
  balanced: { bitrate: 4_000_000, label: 'Balanced' },
  compact:  { bitrate: 1_500_000, label: 'Compact' },
};

let selectedQuality = 'youtube';
let encFile = null, encBlob = null, encBlobUrl = null;
let decFile = null, decResult = null, decBlobUrl = null;
let encCancelled = false, decCancelled = false;

if (!('VideoEncoder' in window)) {
  document.getElementById('compatWarn').style.display = 'block';
}

const $ = id => document.getElementById(id);

class PayloadView {
  constructor(headerBytes, fileData) {
    this.fileData = fileData;
    const hl = headerBytes.length;
    this.prefix = new Uint8Array(8 + hl);
    this.prefix[0] = 0x46; this.prefix[1] = 0x32;
    this.prefix[2] = 0x56; this.prefix[3] = 0x31;
    this.prefix[4] = (hl >>> 24) & 0xFF;
    this.prefix[5] = (hl >>> 16) & 0xFF;
    this.prefix[6] = (hl >>> 8) & 0xFF;
    this.prefix[7] = hl & 0xFF;
    this.prefix.set(headerBytes, 8);
    this.prefixLen = this.prefix.length;
    this.length = this.prefixLen + fileData.length;
  }

  getFrameSlice(frameIdx) {
    const offset = frameIdx * BYTES_PER_FRAME;
    const end = Math.min(offset + BYTES_PER_FRAME, this.length);
    if (end <= offset) return null;
    if (offset >= this.prefixLen) {
      return this.fileData.subarray(offset - this.prefixLen, end - this.prefixLen);
    }
    if (end <= this.prefixLen) {
      return this.prefix.subarray(offset, end);
    }
    const result = new Uint8Array(end - offset);
    result.set(this.prefix.subarray(offset, this.prefixLen));
    result.set(this.fileData.subarray(0, end - this.prefixLen), this.prefixLen - offset);
    return result;
  }
}

function fmtSize(b) {
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b/1024).toFixed(1) + ' KB';
  if (b < 1073741824) return (b/1048576).toFixed(2) + ' MB';
  return (b/1073741824).toFixed(2) + ' GB';
}

function fmtTime(sec) {
  if (sec < 60) return Math.round(sec) + 's';
  const m = Math.floor(sec / 60);
  const s = Math.round(sec % 60);
  return m + 'm ' + s + 's';
}

function estimateOutputSize(fileSize, quality) {
  const hdrEstimate = 150;
  const payloadSize = 4 + 4 + hdrEstimate + fileSize;
  const totalValues = payloadSize * 4;
  const dataFrames = Math.ceil(totalValues / BPF);
  const totalFrames = Math.max(dataFrames, MIN_FRAMES);
  const duration = totalFrames / FPS;
  const bitrate = QUALITY[quality].bitrate;
  return { est: Math.ceil(duration * bitrate / 8), frames: totalFrames, duration };
}

function updateEstimate() {
  const el = $('estInfo');
  const warnEl = $('sizeWarn');
  if (!encFile) { el.classList.remove('show'); warnEl.classList.remove('show'); return; }
  const info = estimateOutputSize(encFile.size, selectedQuality);
  $('estText').innerHTML = 'Estimated video: <span class="est-val">' + fmtSize(info.est) + '</span> &middot; ' + info.frames + ' frames &middot; ' + fmtTime(info.duration) + ' &middot; ' + QUALITY[selectedQuality].label;
  el.classList.add('show');

  if (encFile.size > 25 * 1024 * 1024) {
    warnEl.textContent = 'Very large file (' + fmtSize(encFile.size) + '). Encoding may take a long time and use significant memory. For files >50MB consider a desktop tool.';
    warnEl.classList.add('show');
  } else if (encFile.size > 10 * 1024 * 1024) {
    warnEl.textContent = 'Large file (' + fmtSize(encFile.size) + '). Encoding may take several minutes. Please do not close the browser tab.';
    warnEl.classList.add('show');
  } else {
    warnEl.classList.remove('show');
  }
}

async function sha256(buf) {
  const h = await crypto.subtle.digest('SHA-256', buf);
  return Array.from(new Uint8Array(h)).map(b => b.toString(16).padStart(2,'0')).join('');
}

function setupDrop(zoneId, inputId, onFile) {
  const zone = $(zoneId), inp = $(inputId);
  zone.addEventListener('click', () => inp.click());
  zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag'); });
  zone.addEventListener('dragleave', () => zone.classList.remove('drag'));
  zone.addEventListener('drop', e => { e.preventDefault(); zone.classList.remove('drag'); if(e.dataTransfer.files[0]) onFile(e.dataTransfer.files[0]); });
  inp.addEventListener('change', () => { if(inp.files[0]) onFile(inp.files[0]); inp.value = ''; });
}

function showStatus(id, type, msg) {
  const el = $(id);
  el.className = 'status show ' + type;
  const icons = {info:'&#9432;',ok:'&#10003;',err:'&#10007;',warn:'&#9888;'};
  el.innerHTML = '<span class="s-icon">' + (icons[type]||'') + '</span><span>' + msg + '</span>';
}
function hideStatus(id) { $(id).className = 'status'; }

function setProgress(barId, pctId, statusId, pct, text) {
  $(barId).style.width = Math.min(100, pct) + '%';
  $(pctId).textContent = Math.round(pct) + '%';
  $(statusId).textContent = text;
}

document.querySelectorAll('.tab').forEach(t => {
  t.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
    document.querySelectorAll('.section').forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    $(t.dataset.tab + 'Section').classList.add('active');
  });
});

document.querySelectorAll('.quality-opt').forEach(el => {
  el.addEventListener('click', () => {
    document.querySelectorAll('.quality-opt').forEach(x => x.classList.remove('active'));
    el.classList.add('active');
    selectedQuality = el.dataset.quality;
    updateEstimate();
  });
});

function cleanupEncBlob() {
  if (encBlobUrl) { URL.revokeObjectURL(encBlobUrl); encBlobUrl = null; }
  encBlob = null;
}

function resetEncUI() {
  $('encDlArea').classList.remove('show');
  $('encSpecs').style.display = 'none';
  $('encHashArea').style.display = 'none';
  $('encProgress').classList.remove('show');
  $('encCancelBtn').style.display = 'none';
  hideStatus('encStatusMsg');
  cleanupEncBlob();
}

setupDrop('encDropZone', 'encFileInput', f => {
  encFile = f;
  $('encDropZone').style.display = 'none';
  $('encFileInfo').style.display = 'flex';
  $('encFileName').textContent = f.name;
  $('encFileSize').textContent = fmtSize(f.size);
  $('encodeBtn').disabled = false;
  resetEncUI();
  updateEstimate();
});

$('encRemoveBtn').addEventListener('click', () => {
  encFile = null;
  $('encDropZone').style.display = '';
  $('encFileInfo').style.display = 'none';
  $('encodeBtn').disabled = true;
  resetEncUI();
  updateEstimate();
});

function cleanupDecBlob() {
  if (decBlobUrl) { URL.revokeObjectURL(decBlobUrl); decBlobUrl = null; }
  decResult = null;
}

setupDrop('decDropZone', 'decFileInput', f => {
  decFile = f;
  $('decDropZone').style.display = 'none';
  $('decFileInfo').style.display = 'flex';
  $('decFileName').textContent = f.name;
  $('decFileSize').textContent = fmtSize(f.size);
  $('decodeBtn').disabled = false;
  $('decDlArea').classList.remove('show');
  $('decVerify').className = 'verify-result';
  $('decHashArea').style.display = 'none';
  $('decProgress').classList.remove('show');
  $('decCancelBtn').style.display = 'none';
  hideStatus('decStatusMsg');
  cleanupDecBlob();
});

$('decRemoveBtn').addEventListener('click', () => {
  decFile = null;
  $('decDropZone').style.display = '';
  $('decFileInfo').style.display = 'none';
  $('decodeBtn').disabled = true;
  $('decDlArea').classList.remove('show');
  $('decProgress').classList.remove('show');
  $('decVerify').className = 'verify-result';
  $('decHashArea').style.display = 'none';
  $('decCancelBtn').style.display = 'none';
  hideStatus('decStatusMsg');
  cleanupDecBlob();
});

function renderFrame(uint32View, frameIdx, payload) {
  const slice = payload.getFrameSlice(frameIdx);
  for (let blockRow = 0; blockRow < ROWS; blockRow++) {
    const baseY = blockRow * BS;
    for (let c = 0; c < COLS; c++) {
      const blockIdx = blockRow * COLS + c;
      const localByte = blockIdx >>> 2;
      const bitShift = (3 - (blockIdx & 3)) * 2;
      let val = 0;
      if (slice && localByte < slice.length) {
        val = (slice[localByte] >>> bitShift) & 3;
      }
      const color = COLORS_U32[val];
      const startX = c * BS;
      for (let py = 0; py < BS; py++) {
        const rowStart = (baseY + py) * W + startX;
        uint32View.fill(color, rowStart, rowStart + BS);
      }
    }
  }
}

$('encCancelBtn').addEventListener('click', () => { encCancelled = true; });

$('encodeBtn').addEventListener('click', async () => {
  if (!encFile) return;
  const btn = $('encodeBtn');
  btn.disabled = true;
  encCancelled = false;
  $('encCancelBtn').style.display = '';
  $('encProgress').classList.add('show');
  resetEncUI();
  $('encProgress').classList.add('show');
  $('encCancelBtn').style.display = '';

  const quality = QUALITY[selectedQuality];
  let encoder = null;

  try {
    setProgress('encBar','encPercent','encStatus', 1, 'Reading file...');
    await new Promise(r => setTimeout(r, 0));

    const fileData = new Uint8Array(await encFile.arrayBuffer());
    if (encCancelled) throw new Error('Cancelled by user');

    setProgress('encBar','encPercent','encStatus', 4, 'Computing SHA-256...');
    await new Promise(r => setTimeout(r, 0));
    const hash = await sha256(fileData);
    if (encCancelled) throw new Error('Cancelled by user');

    setProgress('encBar','encPercent','encStatus', 7, 'Preparing data...');
    const header = JSON.stringify({ name: encFile.name, size: fileData.length, hash: hash, v: 2 });
    const headerBytes = new TextEncoder().encode(header);
    const payload = new PayloadView(headerBytes, fileData);
    const dataFrames = Math.ceil(payload.length * 4 / BPF);
    const totalFrames = Math.max(dataFrames, MIN_FRAMES);

    $('specFrames').textContent = totalFrames + (totalFrames > dataFrames ? ' (' + dataFrames + ' data + ' + (totalFrames - dataFrames) + ' padding)' : '');
    $('specBitrate').textContent = (quality.bitrate / 1_000_000) + ' Mbps';
    $('specDataRate').textContent = BYTES_PER_FRAME + ' bytes/frame';
    $('encSpecs').style.display = 'grid';
    $('encHashArea').style.display = 'block';
    $('encHash').textContent = hash;

    setProgress('encBar','encPercent','encStatus', 9, 'Initializing H.264 encoder...');
    await new Promise(r => setTimeout(r, 0));

    const codecString = 'avc1.42001f';
    const support = await VideoEncoder.isConfigSupported({
      codec: codecString, width: W, height: H,
      bitrate: quality.bitrate, framerate: FPS,
    });
    if (!support.supported) throw new Error('H.264 encoding is not supported by this browser.');

    const muxer = new Muxer({
      target: new ArrayBufferTarget(),
      video: { codec: 'avc', width: W, height: H },
      fastStart: 'in-memory',
    });

    let encError = null;
    encoder = new VideoEncoder({
      output: (chunk, meta) => { muxer.addVideoChunk(chunk, meta); },
      error: e => { encError = e; },
    });

    encoder.configure({
      codec: codecString, width: W, height: H,
      bitrate: quality.bitrate, framerate: FPS,
      latencyMode: 'quality',
    });

    const canvas = new OffscreenCanvas(W, H);
    const ctx = canvas.getContext('2d');
    const imgData = ctx.createImageData(W, H);
    const uint32View = new Uint32Array(imgData.data.buffer);

    const MAX_QUEUE = 8;
    const startTime = performance.now();
    let lastYieldTime = startTime;
    let lastFrameSlice = null;

    for (let i = 0; i < totalFrames; i++) {
      if (encCancelled) throw new Error('Cancelled by user');
      if (encError) throw encError;

      if (i < dataFrames) {
        renderFrame(uint32View, i, payload);
      } else if (i === dataFrames && dataFrames > 0) {
        renderFrame(uint32View, dataFrames - 1, payload);
      }

      ctx.putImageData(imgData, 0, 0);

      const frame = new VideoFrame(canvas, {
        timestamp: i * (1_000_000 / FPS),
        duration: 1_000_000 / FPS,
      });

      while (encoder.encodeQueueSize >= MAX_QUEUE) {
        await new Promise(resolve => {
          const onDequeue = () => { resolve(); };
          encoder.addEventListener('dequeue', onDequeue, { once: true });
        });
        if (encCancelled) { frame.close(); throw new Error('Cancelled by user'); }
        if (encError) { frame.close(); throw encError; }
      }

      encoder.encode(frame, { keyFrame: true });
      frame.close();

      const now = performance.now();
      if (now - lastYieldTime > 30 || i === totalFrames - 1) {
        const pct = 10 + (i / totalFrames) * 85;
        const elapsed = (now - startTime) / 1000;
        const framesPerSec = (i + 1) / elapsed;
        const remaining = (totalFrames - i - 1) / framesPerSec;
        const etaStr = i > 10 ? ' (ETA: ' + fmtTime(remaining) + ')' : '';
        setProgress('encBar','encPercent','encStatus', pct, 'Frame ' + (i+1) + '/' + totalFrames + etaStr);
        await new Promise(r => setTimeout(r, 0));
        lastYieldTime = performance.now();
      }
    }

    setProgress('encBar','encPercent','encStatus', 96, 'Flushing encoder...');
    await new Promise(r => setTimeout(r, 0));

    await encoder.flush();
    encoder.close();
    encoder = null;
    muxer.finalize();

    if (encError) throw encError;

    const mp4Buf = muxer.target.buffer;
    encBlob = new Blob([mp4Buf], { type: 'video/mp4' });

    setProgress('encBar','encPercent','encStatus', 100, 'Done!');
    const duration = (totalFrames / FPS).toFixed(1);
    showStatus('encStatusMsg','ok',
      'Video created: ' + totalFrames + ' frames, ' + duration + 's, ' + fmtSize(mp4Buf.byteLength) + '. Ready to download.');
    $('encDlArea').classList.add('show');

  } catch(e) {
    if (encoder) { try { encoder.close(); } catch(_){} }
    if (e.message === 'Cancelled by user') {
      showStatus('encStatusMsg','warn','Encoding cancelled.');
    } else {
      console.error(e);
      showStatus('encStatusMsg','err','Encoding failed: ' + e.message);
    }
  }
  btn.disabled = false;
  $('encCancelBtn').style.display = 'none';
});

$('encDlBtn').addEventListener('click', () => {
  if (!encBlob) return;
  if (encBlobUrl) URL.revokeObjectURL(encBlobUrl);
  encBlobUrl = URL.createObjectURL(encBlob);
  const name = encFile ? encFile.name.replace(/\.[^.]+$/,'') + '_encoded.mp4' : 'encoded.mp4';
  const a = document.createElement('a');
  a.href = encBlobUrl;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
});

function sampleBlock(data, w, bx, by) {
  let tr=0,tg=0,tb=0;

  const sx = bx*BS, sy = by*BS;
  const ex = (bx+1)*BS, ey = (by+1)*BS;
  const count = (ex - sx) * (ey - sy);
  for (let y=sy; y<ey; y++) {
    const rowBase = y * w * 4;
    for (let x=sx; x<ex; x++) {
      const idx = rowBase + x * 4;
      tr += data[idx]; tg += data[idx+1]; tb += data[idx+2];
    }
  }
  const ar=tr/count, ag=tg/count, ab=tb/count;
  let best=0, minD=Infinity;
  for (let v=0;v<4;v++) {
    const dr = ar-COLORS[v][0], dg = ag-COLORS[v][1], db = ab-COLORS[v][2];
    const d = dr*dr + dg*dg + db*db;
    if(d<minD){minD=d;best=v;}
  }
  return best;
}

function extractFrameBytes(imgData, w) {
  const frameBytes = new Uint8Array(BYTES_PER_FRAME);
  for (let bi = 0; bi < BPF; bi += 4) {
    const r0 = Math.floor(bi / COLS), c0 = bi % COLS;
    const r1 = Math.floor((bi+1) / COLS), c1 = (bi+1) % COLS;
    const r2 = Math.floor((bi+2) / COLS), c2 = (bi+2) % COLS;
    const r3 = Math.floor((bi+3) / COLS), c3 = (bi+3) % COLS;
    const v0 = sampleBlock(imgData, w, c0, r0);
    const v1 = sampleBlock(imgData, w, c1, r1);
    const v2 = sampleBlock(imgData, w, c2, r2);
    const v3 = sampleBlock(imgData, w, c3, r3);
    frameBytes[bi >>> 2] = (v0 << 6) | (v1 << 4) | (v2 << 2) | v3;
  }
  return frameBytes;
}

$('decCancelBtn').addEventListener('click', () => { decCancelled = true; });

$('decodeBtn').addEventListener('click', async () => {
  if (!decFile) return;
  const btn = $('decodeBtn');
  btn.disabled = true;
  decCancelled = false;
  $('decCancelBtn').style.display = '';
  $('decProgress').classList.add('show');
  $('decDlArea').classList.remove('show');
  $('decVerify').className = 'verify-result';
  $('decHashArea').style.display = 'none';
  hideStatus('decStatusMsg');
  cleanupDecBlob();

  let videoUrl = null;

  try {
    setProgress('decBar','decPercent','decStatus', 1, 'Loading video...');
    await new Promise(r => setTimeout(r, 0));

    const video = document.createElement('video');
    video.muted = true;
    video.playsInline = true;
    video.preload = 'auto';
    videoUrl = URL.createObjectURL(decFile);
    video.src = videoUrl;

    await new Promise((res, rej) => {
      video.onloadedmetadata = res;
      video.onerror = () => rej(new Error('Failed to load video. Make sure it is a valid video file.'));
    });
    await new Promise((res) => {
      video.oncanplaythrough = res;
      video.load();
    });

    const canvas = document.createElement('canvas');
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const estFrames = Math.max(1, Math.round(video.duration * FPS));

    setProgress('decBar','decPercent','decStatus', 3, 'Extracting ' + estFrames + ' frames...');

    let outputBuffer = null;
    let outputOffset = 0;
    let headerParsed = false;
    let totalNeeded = 0;
    let parsedHeader = null;
    const tempBuffer = new Uint8Array(Math.min(estFrames * BYTES_PER_FRAME, 50000));
    let tempOffset = 0;

    const startTime = performance.now();
    let lastYieldTime = startTime;

    for (let i = 0; i < estFrames; i++) {
      if (decCancelled) throw new Error('Cancelled by user');

      const t = (i + 0.02) / FPS;
      if (t > video.duration + 0.5) break;

      video.currentTime = t;
      await new Promise(r => { video.onseeked = r; });

      ctx.drawImage(video, 0, 0, W, H);
      const imgData = ctx.getImageData(0, 0, W, H);

      const frameBytes = extractFrameBytes(imgData.data, W);

      if (!headerParsed) {
        const copyLen = Math.min(BYTES_PER_FRAME, tempBuffer.length - tempOffset);
        if (copyLen > 0) {
          tempBuffer.set(frameBytes.subarray(0, copyLen), tempOffset);
          tempOffset += copyLen;
        }

        if (tempOffset >= 8) {
          if (tempBuffer[0] !== MAGIC[0] || tempBuffer[1] !== MAGIC[1] ||
              tempBuffer[2] !== MAGIC[2] || tempBuffer[3] !== MAGIC[3]) {
            throw new Error('This video does not contain encoded file data (magic number not found).');
          }
          const hl = (tempBuffer[4]<<24)|(tempBuffer[5]<<16)|(tempBuffer[6]<<8)|tempBuffer[7];
          if (hl > 10000 || hl < 10) {
            throw new Error('Invalid header length (' + hl + '). The video may be corrupted.');
          }
          if (tempOffset >= 8 + hl) {
            try {
              const hdrJson = new TextDecoder().decode(tempBuffer.slice(8, 8+hl));
              parsedHeader = JSON.parse(hdrJson);
              totalNeeded = 8 + hl + parsedHeader.size;
              outputBuffer = new Uint8Array(totalNeeded);
              const toCopy = Math.min(tempOffset, totalNeeded);
              outputBuffer.set(tempBuffer.subarray(0, toCopy));
              outputOffset = toCopy;
              headerParsed = true;
            } catch(e) {
              throw new Error('Failed to parse header: ' + e.message);
            }
          }
        }
      } else {
        const remaining = totalNeeded - outputOffset;
        if (remaining > 0) {
          const toCopy = Math.min(BYTES_PER_FRAME, remaining);
          outputBuffer.set(frameBytes.subarray(0, toCopy), outputOffset);
          outputOffset += toCopy;
        }
        if (outputOffset >= totalNeeded) {
          setProgress('decBar','decPercent','decStatus', 90, 'All data frames extracted.');
          break;
        }
      }

      const now = performance.now();
      if (now - lastYieldTime > 50 || i === estFrames - 1) {
        const pct = 5 + ((i+1)/estFrames)*80;
        const elapsed = (now - startTime) / 1000;
        const fps = (i + 1) / elapsed;
        const framesLeft = headerParsed ? Math.ceil((totalNeeded - outputOffset) / BYTES_PER_FRAME) : (estFrames - i - 1);
        const remaining = framesLeft / fps;
        const etaStr = i > 3 ? ' (ETA: ' + fmtTime(remaining) + ')' : '';
        setProgress('decBar','decPercent','decStatus', pct, 'Frame ' + (i+1) + '/' + estFrames + etaStr);
        await new Promise(r => setTimeout(r, 0));
        lastYieldTime = performance.now();
      }
    }

    if (videoUrl) { URL.revokeObjectURL(videoUrl); videoUrl = null; }

    if (!headerParsed) {
      throw new Error('Could not find encoded data in this video. Make sure you are using a video created by this tool.');
    }

    if (outputOffset < totalNeeded) {
      throw new Error('Video does not contain enough data. Expected ' + totalNeeded + ' bytes but got ' + outputOffset + '. The video may be incomplete.');
    }

    setProgress('decBar','decPercent','decStatus', 92, 'Extracting file data...');
    await new Promise(r => setTimeout(r, 0));

    const hl = (outputBuffer[4]<<24)|(outputBuffer[5]<<16)|(outputBuffer[6]<<8)|outputBuffer[7];
    const fileData = outputBuffer.slice(8 + hl, 8 + hl + parsedHeader.size);

    setProgress('decBar','decPercent','decStatus', 95, 'Verifying SHA-256...');
    await new Promise(r => setTimeout(r, 0));
    const actualHash = await sha256(fileData);
    const isValid = actualHash === parsedHeader.hash;

    setProgress('decBar','decPercent','decStatus', 100, 'Done!');

    $('decHashArea').style.display = 'block';
    $('decHashExpected').textContent = parsedHeader.hash;
    $('decHashActual').textContent = actualHash;

    const vr = $('decVerify');
    if (isValid) {
      vr.className = 'verify-result show pass';
      vr.textContent = 'SHA-256 MATCH \u2014 File integrity verified. No data loss.';
      showStatus('decStatusMsg','ok', 'File "' + parsedHeader.name + '" (' + fmtSize(parsedHeader.size) + ') extracted successfully.');
    } else {
      vr.className = 'verify-result show fail';
      vr.textContent = 'SHA-256 MISMATCH \u2014 File may be corrupted. This can happen after YouTube re-encoding.';
      showStatus('decStatusMsg','warn', 'File "' + parsedHeader.name + '" extracted but SHA-256 does not match. The file may have minor corruption from video compression.');
    }

    decResult = { data: fileData, filename: parsedHeader.name };
    $('decDlArea').classList.add('show');

  } catch(e) {
    if (videoUrl) { URL.revokeObjectURL(videoUrl); videoUrl = null; }
    if (e.message === 'Cancelled by user') {
      showStatus('decStatusMsg','warn','Decoding cancelled.');
    } else {
      console.error(e);
      showStatus('decStatusMsg','err', 'Decoding failed: ' + e.message);
    }
  }
  btn.disabled = false;
  $('decCancelBtn').style.display = 'none';
});

$('decDlBtn').addEventListener('click', () => {
  if (!decResult) return;
  if (decBlobUrl) URL.revokeObjectURL(decBlobUrl);
  const blob = new Blob([decResult.data]);
  decBlobUrl = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = decBlobUrl;
  a.download = decResult.filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
});
</script>
</body>
</html>
