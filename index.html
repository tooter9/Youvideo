<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SwampCrypt</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
:root{
--bg:#050a05;--card:#0a150a;--card2:#0d1f0d;--border:#1a3a1a;
--text:#c8e6c8;--text2:#4a7a4a;--accent:#00ff41;--accent2:#1a8a1a;
--success:#00ff41;--danger:#ff3333;--warning:#ffd700;
--radius:12px;--font:'Share Tech Mono','Courier New',monospace;--font-title:'Orbitron','Impact',sans-serif;
}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:var(--font);line-height:1.6}
body::after{content:'';position:fixed;top:0;left:0;right:0;bottom:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,255,65,.03) 2px,rgba(0,255,65,.03) 4px);pointer-events:none;z-index:9999}
a{color:var(--accent);text-decoration:none}
.wrap{max-width:780px;margin:0 auto;padding:24px 20px 60px;position:relative;z-index:1}
.header{text-align:center;padding:40px 0 32px}
.header h1{font-family:var(--font-title);font-size:32px;font-weight:700;color:var(--accent);text-shadow:0 0 20px rgba(0,255,65,.5),0 0 40px rgba(0,255,65,.2);letter-spacing:3px;animation:glitch 4s ease-in-out infinite}
.header .subtitle{color:var(--text2);font-size:13px;margin-top:8px;letter-spacing:1px}
.header .subtitle::after{content:'_';animation:blink 1s step-end infinite}
.header .shrek-quote{color:var(--accent);font-size:11px;margin-top:6px;opacity:.5;font-style:italic}
@keyframes glitch{0%,100%{text-shadow:0 0 20px rgba(0,255,65,.5),0 0 40px rgba(0,255,65,.2)}25%{text-shadow:-2px 0 rgba(255,0,0,.4),2px 0 rgba(0,255,0,.4),0 0 20px rgba(0,255,65,.5)}50%{text-shadow:0 0 30px rgba(0,255,65,.7),0 0 60px rgba(0,255,65,.3)}75%{text-shadow:2px 0 rgba(255,0,0,.3),-2px 0 rgba(0,255,0,.3),0 0 20px rgba(0,255,65,.5)}}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0}}
.tabs{display:flex;gap:4px;background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:4px;margin-bottom:24px}
.tab{flex:1;padding:12px;text-align:center;border-radius:8px;cursor:pointer;font-weight:600;font-size:14px;color:var(--text2);transition:all .2s;border:none;background:none;font-family:var(--font)}
.tab.active{background:var(--accent2);color:var(--accent);box-shadow:0 0 10px rgba(0,255,65,.2)}
.tab:hover:not(.active){color:var(--text);background:var(--card2)}
.section{display:none}.section.active{display:block}
.card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:24px;margin-bottom:16px}
.drop-zone{border:2px dashed var(--border);border-radius:var(--radius);padding:48px 24px;text-align:center;cursor:pointer;transition:all .25s}
.drop-zone:hover,.drop-zone.drag{border-color:var(--accent);background:rgba(0,255,65,.04);box-shadow:0 0 20px rgba(0,255,65,.1) inset}
.drop-zone .icon{font-size:40px;margin-bottom:12px;opacity:.5}
.drop-zone .label{font-size:15px;font-weight:600;color:var(--text)}
.drop-zone .sub{font-size:13px;color:var(--text2);margin-top:4px}
.file-info{display:flex;align-items:center;gap:12px;padding:14px 16px;background:var(--card2);border:1px solid var(--border);border-radius:8px;margin-top:16px}
.file-info .fi-icon{width:40px;height:40px;border-radius:8px;background:var(--accent2);display:flex;align-items:center;justify-content:center;font-size:18px;flex-shrink:0}
.file-info .fi-details{flex:1;min-width:0}
.file-info .fi-name{font-size:14px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.file-info .fi-size{font-size:12px;color:var(--text2)}
.file-info .fi-remove{width:32px;height:32px;border:none;background:none;color:var(--text2);cursor:pointer;font-size:18px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-family:var(--font)}
.file-info .fi-remove:hover{background:rgba(255,51,51,.15);color:var(--danger)}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:14px 28px;border:none;border-radius:8px;font-size:15px;font-weight:600;cursor:pointer;transition:all .2s;width:100%;font-family:var(--font);letter-spacing:1px;text-transform:uppercase}
.btn-primary{background:var(--accent2);color:var(--accent);border:1px solid rgba(0,255,65,.3);box-shadow:0 0 15px rgba(0,255,65,.15)}
.btn-primary:hover:not(:disabled){background:#20a020;box-shadow:0 0 25px rgba(0,255,65,.3)}
.btn-primary:disabled{opacity:.3;cursor:not-allowed;box-shadow:none}
.btn-success{background:#059669;color:#fff;border:1px solid #34d399}
.btn-success:hover{background:#047857}
.btn-cancel{background:var(--danger);color:#fff;margin-top:8px;border:1px solid #ff6666}
.btn-cancel:hover{background:#cc0000}
.progress-wrap{margin-top:16px;display:none}
.progress-wrap.show{display:block}
.progress-bar-bg{height:8px;background:var(--card2);border-radius:4px;overflow:hidden;border:1px solid var(--border)}
.progress-bar{height:100%;background:linear-gradient(90deg,var(--accent2),var(--accent));border-radius:4px;width:0%;transition:width .3s;box-shadow:0 0 10px rgba(0,255,65,.3)}
.progress-text{display:flex;justify-content:space-between;margin-top:8px;font-size:12px;color:var(--text2)}
.status{margin-top:16px;padding:14px 16px;border-radius:8px;font-size:13px;display:none;align-items:flex-start;gap:10px;line-height:1.5}
.status.show{display:flex}
.status.info{background:rgba(0,255,65,.05);border:1px solid rgba(0,255,65,.15);color:var(--accent)}
.status.ok{background:rgba(0,255,65,.08);border:1px solid rgba(0,255,65,.25);color:var(--success)}
.status.err{background:rgba(255,51,51,.08);border:1px solid rgba(255,51,51,.25);color:var(--danger)}
.status.warn{background:rgba(255,215,0,.08);border:1px solid rgba(255,215,0,.25);color:var(--warning)}
.status .s-icon{font-size:16px;flex-shrink:0;margin-top:1px}
.dl-area{margin-top:16px;display:none}
.dl-area.show{display:block}
.specs{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:16px}
.spec{padding:10px 12px;background:var(--card2);border:1px solid var(--border);border-radius:8px;font-size:12px}
.spec .spec-label{color:var(--text2);font-size:11px;text-transform:uppercase;letter-spacing:.5px}
.spec .spec-value{font-weight:600;margin-top:2px;color:var(--accent)}
.est-info{margin-top:12px;padding:10px 14px;background:var(--card2);border:1px solid var(--border);border-radius:8px;font-size:13px;color:var(--text2);display:none}
.est-info.show{display:flex;align-items:center;gap:8px}
.est-info .est-val{color:var(--accent);font-weight:600}
.size-warn{margin-top:8px;padding:10px 14px;background:rgba(255,215,0,.06);border:1px solid rgba(255,215,0,.2);border-radius:8px;font-size:12px;color:var(--warning);display:none}
.size-warn.show{display:block}
.compat-warn{padding:20px;background:rgba(255,51,51,.08);border:1px solid rgba(255,51,51,.25);border-radius:var(--radius);color:var(--danger);text-align:center;margin-bottom:24px;font-size:14px}
.compat-warn strong{display:block;font-size:16px;margin-bottom:4px}
.cover-status{margin-bottom:16px;padding:10px 14px;background:var(--card2);border:1px solid var(--border);border-radius:8px;font-size:12px;display:flex;align-items:center;gap:8px}
.cover-status .dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.cover-status .dot.ok{background:var(--accent);box-shadow:0 0 6px var(--accent)}
.cover-status .dot.err{background:var(--danger);box-shadow:0 0 6px var(--danger)}
.cover-status .dot.loading{background:var(--warning);animation:pulse 1s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}
.footer-social{display:flex;justify-content:center;gap:16px;padding:32px 0 16px}
.social-link{width:40px;height:40px;border-radius:50%;background:var(--card2);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;color:var(--text2);transition:all .2s}
.social-link:hover{background:var(--accent2);border-color:var(--accent);color:var(--accent);box-shadow:0 0 15px rgba(0,255,65,.2)}
.social-link svg{width:20px;height:20px;fill:currentColor}
.matrix-bg{position:fixed;top:0;left:0;right:0;bottom:0;z-index:0;opacity:.04}
@media(max-width:600px){
.wrap{padding:16px 12px 40px}
.header{padding:24px 0 20px}
.header h1{font-size:24px}
.card{padding:16px}
.drop-zone{padding:32px 16px}
.specs{grid-template-columns:1fr}
}
</style>
</head>
<body>
<canvas id="matrixBg" class="matrix-bg"></canvas>
<div class="wrap">
<div class="header">
<h1>SWAMPCRYPT</h1>
<p class="subtitle">// steganography_engine v3.0</p>
<p class="shrek-quote">"Ogres have layers. Data has layers." — Shrek</p>
</div>

<div id="compatWarn" class="compat-warn" style="display:none">
<strong>Browser Not Supported</strong>
<span>WebCodecs API required. Use Chrome or Edge.</span>
</div>

<div class="tabs">
<div class="tab active" data-tab="encode">[ ENCODE ]</div>
<div class="tab" data-tab="decode">[ DECODE ]</div>
</div>

<div id="encodeSection" class="section active">
<div class="card">
<div id="encDropZone" class="drop-zone">
<div class="icon">&#128196;</div>
<div class="label">Drop file into the swamp</div>
<div class="sub">Any file type — nobody will find it</div>
</div>
<input type="file" id="encFileInput" style="display:none">
<div id="encFileInfo" class="file-info" style="display:none">
<div class="fi-icon">&#128196;</div>
<div class="fi-details">
<div id="encFileName" class="fi-name"></div>
<div id="encFileSize" class="fi-size"></div>
</div>
<button id="encRemoveBtn" class="fi-remove" title="Remove">&times;</button>
</div>
</div>

<div id="coverStatus" class="cover-status">
<span class="dot loading" id="coverDot"></span>
<span id="coverText">Loading cover video...</span>
</div>

<div id="estInfo" class="est-info">
<span>&#8505;</span>
<span id="estText"></span>
</div>
<div id="sizeWarn" class="size-warn"></div>

<button id="encodeBtn" class="btn btn-primary" disabled>HIDE IN SWAMP</button>
<button id="encCancelBtn" class="btn btn-cancel" style="display:none">GET OUTTA MY SWAMP</button>

<div id="encProgress" class="progress-wrap">
<div class="progress-bar-bg"><div id="encBar" class="progress-bar"></div></div>
<div class="progress-text"><span id="encPercent">0%</span><span id="encStatus">Initializing...</span></div>
</div>

<div id="encStatusMsg" class="status"></div>

<div id="encSpecs" class="specs" style="display:none">
<div class="spec"><div class="spec-label">Resolution</div><div id="specRes" class="spec-value">1280 x 720</div></div>
<div class="spec"><div class="spec-label">Codec</div><div class="spec-value">H.264 / AVC</div></div>
<div class="spec"><div class="spec-label">Method</div><div class="spec-value">QIM + ECC</div></div>
<div class="spec"><div class="spec-label">Frames</div><div id="specFrames" class="spec-value">&mdash;</div></div>
<div class="spec"><div class="spec-label">Capacity</div><div id="specCapacity" class="spec-value">&mdash;</div></div>
<div class="spec"><div class="spec-label">Bitrate</div><div class="spec-value">8 Mbps</div></div>
</div>

<div id="encDlArea" class="dl-area">
<button id="encDlBtn" class="btn btn-success">DOWNLOAD OGRE VIDEO</button>
</div>
</div>

<div id="decodeSection" class="section">
<div class="card">
<div id="decDropZone" class="drop-zone">
<div class="icon">&#127916;</div>
<div class="label">Drop encoded video here</div>
<div class="sub">Video created by SwampCrypt</div>
</div>
<input type="file" id="decFileInput" accept="video/*" style="display:none">
<div id="decFileInfo" class="file-info" style="display:none">
<div class="fi-icon">&#127916;</div>
<div class="fi-details">
<div id="decFileName" class="fi-name"></div>
<div id="decFileSize" class="fi-size"></div>
</div>
<button id="decRemoveBtn" class="fi-remove" title="Remove">&times;</button>
</div>
</div>

<button id="decodeBtn" class="btn btn-primary" disabled>EXTRACT FROM SWAMP</button>
<button id="decCancelBtn" class="btn btn-cancel" style="display:none">GET OUTTA MY SWAMP</button>

<div id="decProgress" class="progress-wrap">
<div class="progress-bar-bg"><div id="decBar" class="progress-bar"></div></div>
<div class="progress-text"><span id="decPercent">0%</span><span id="decStatus">Preparing...</span></div>
</div>

<div id="decStatusMsg" class="status"></div>

<div id="decDlArea" class="dl-area">
<button id="decDlBtn" class="btn btn-success">DOWNLOAD EXTRACTED FILE</button>
</div>
</div>

<div class="footer-social">
<a href="https://github.com/tooter9" target="_blank" rel="noopener" class="social-link" title="GitHub">
<svg viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61-.546-1.385-1.335-1.755-1.335-1.755-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 21.795 24 17.295 24 12c0-6.63-5.37-12-12-12z"/></svg>
</a>
<a href="https://x.com/elonmusk" target="_blank" rel="noopener" class="social-link" title="X (Twitter)">
<svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
</a>
</div>
</div>

<script type="module">
import { Muxer, ArrayBufferTarget } from 'https://cdn.jsdelivr.net/npm/mp4-muxer@5/+esm';

const W = 1280, H = 720, FPS = 30, BITRATE = 8_000_000;
const COVER_URL = 'Shrek.mp4';
const SBS = 4;
const SCOLS = W / SBS, SROWS = H / SBS;
const BPF = SCOLS * SROWS;
const BYTES_PER_FRAME = BPF >>> 3;
const Q = 48;
const REDUNDANCY = 3;
const EFFECTIVE_BPF = Math.floor(BPF / REDUNDANCY);
const EFFECTIVE_BYTES_PER_FRAME = EFFECTIVE_BPF >>> 3;
const MAGIC = [0x53, 0x57, 0x4D, 0x50];
const MIN_FRAMES = 90;

let encFile = null, encBlob = null, encBlobUrl = null;
let decFile = null, decResult = null, decBlobUrl = null;
let encCancelled = false, decCancelled = false;
let coverVideoReady = false;
let coverVideo = null;

if (!('VideoEncoder' in window)) {
  document.getElementById('compatWarn').style.display = 'block';
}

const $ = id => document.getElementById(id);

function crc32(data) {
  let table = crc32.table;
  if (!table) {
    table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
      let c = i;
      for (let j = 0; j < 8; j++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c;
    }
    crc32.table = table;
  }
  let crc = 0xFFFFFFFF;
  for (let i = 0; i < data.length; i++) {
    crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
  }
  return (crc ^ 0xFFFFFFFF) >>> 0;
}

(function initMatrix() {
  const c = $('matrixBg'), ctx = c.getContext('2d');
  c.width = window.innerWidth; c.height = window.innerHeight;
  const chars = 'SHREKOGRE01SWAMP';
  const fs = 14, cols = Math.floor(c.width / fs);
  const drops = new Array(cols).fill(1);
  function draw() {
    ctx.fillStyle = 'rgba(5,10,5,.05)';
    ctx.fillRect(0, 0, c.width, c.height);
    ctx.fillStyle = '#00ff41';
    ctx.font = fs + 'px monospace';
    for (let i = 0; i < drops.length; i++) {
      ctx.fillText(chars[Math.floor(Math.random() * chars.length)], i * fs, drops[i] * fs);
      if (drops[i] * fs > c.height && Math.random() > .975) drops[i] = 0;
      drops[i]++;
    }
  }
  setInterval(draw, 80);
  window.addEventListener('resize', () => { c.width = window.innerWidth; c.height = window.innerHeight; });
})();

function qimEmbed(val, bit) {
  const half = Q >>> 1;
  let t;
  if (bit === 0) {
    t = Math.round(val / Q) * Q;
  } else {
    t = Math.round((val - half) / Q) * Q + half;
  }
  return Math.max(0, Math.min(255, t));
}

function qimExtract(val) {
  const half = Q >>> 1;
  const d0 = Math.abs(val - Math.round(val / Q) * Q);
  const d1 = Math.abs(val - (Math.round((val - half) / Q) * Q + half));
  return d0 < d1 ? 0 : 1;
}

function interleaveIndices(totalBits) {
  const indices = new Uint32Array(totalBits);
  for (let i = 0; i < totalBits; i++) indices[i] = i;
  let seed = 0x5F3759DF;
  for (let i = totalBits - 1; i > 0; i--) {
    seed = (seed * 1103515245 + 12345) & 0x7FFFFFFF;
    const j = seed % (i + 1);
    const tmp = indices[i];
    indices[i] = indices[j];
    indices[j] = tmp;
  }
  return indices;
}

function embedFrame(imgData, slice) {
  const d = imgData.data;
  const totalBits = BPF;
  const logicalBits = EFFECTIVE_BPF;

  const dataBits = new Uint8Array(logicalBits);
  if (slice) {
    for (let i = 0; i < logicalBits; i++) {
      const byteI = i >>> 3;
      const bitP = 7 - (i & 7);
      if (byteI < slice.length) {
        dataBits[i] = (slice[byteI] >>> bitP) & 1;
      }
    }
  }

  const expandedBits = new Uint8Array(totalBits);
  for (let i = 0; i < logicalBits; i++) {
    for (let r = 0; r < REDUNDANCY; r++) {
      expandedBits[i * REDUNDANCY + r] = dataBits[i];
    }
  }

  const interleaveMap = interleaveIndices(totalBits);
  const finalBits = new Uint8Array(totalBits);
  for (let i = 0; i < totalBits; i++) {
    finalBits[interleaveMap[i]] = expandedBits[i];
  }

  let bi = 0;
  for (let by = 0; by < SROWS; by++) {
    const sy = by * SBS;
    for (let bx = 0; bx < SCOLS; bx++) {
      const sx = bx * SBS;
      const bit = finalBits[bi];
      let sumY = 0;
      for (let py = 0; py < SBS; py++) {
        for (let px = 0; px < SBS; px++) {
          const off = ((sy + py) * W + sx + px) << 2;
          sumY += 0.299 * d[off] + 0.587 * d[off + 1] + 0.114 * d[off + 2];
        }
      }
      const avgY = sumY / (SBS * SBS);
      const tgt = qimEmbed(avgY, bit);
      const delta = tgt - avgY;
      for (let py = 0; py < SBS; py++) {
        for (let px = 0; px < SBS; px++) {
          const off = ((sy + py) * W + sx + px) << 2;
          d[off] = Math.max(0, Math.min(255, Math.round(d[off] + delta)));
          d[off + 1] = Math.max(0, Math.min(255, Math.round(d[off + 1] + delta)));
          d[off + 2] = Math.max(0, Math.min(255, Math.round(d[off + 2] + delta)));
        }
      }
      bi++;
    }
  }
}

function extractFrame(imgData) {
  const d = imgData.data;
  const totalBits = BPF;

  const rawBits = new Uint8Array(totalBits);
  let bi = 0;
  for (let by = 0; by < SROWS; by++) {
    const sy = by * SBS;
    for (let bx = 0; bx < SCOLS; bx++) {
      const sx = bx * SBS;
      let sumY = 0;
      for (let py = 0; py < SBS; py++) {
        for (let px = 0; px < SBS; px++) {
          const off = ((sy + py) * W + sx + px) << 2;
          sumY += 0.299 * d[off] + 0.587 * d[off + 1] + 0.114 * d[off + 2];
        }
      }
      const avgY = sumY / (SBS * SBS);
      rawBits[bi] = qimExtract(avgY);
      bi++;
    }
  }

  const interleaveMap = interleaveIndices(totalBits);
  const deinterleavedBits = new Uint8Array(totalBits);
  for (let i = 0; i < totalBits; i++) {
    deinterleavedBits[i] = rawBits[interleaveMap[i]];
  }

  const logicalBits = EFFECTIVE_BPF;
  const out = new Uint8Array(EFFECTIVE_BYTES_PER_FRAME);
  for (let i = 0; i < logicalBits; i++) {
    let votes = 0;
    for (let r = 0; r < REDUNDANCY; r++) {
      votes += deinterleavedBits[i * REDUNDANCY + r];
    }
    const bit = (votes > REDUNDANCY / 2) ? 1 : 0;
    if (bit) out[i >>> 3] |= (1 << (7 - (i & 7)));
  }
  return out;
}

class PayloadView {
  constructor(headerBytes, fileData) {
    this.fileData = fileData;
    const hl = headerBytes.length;
    this.prefix = new Uint8Array(8 + hl);
    this.prefix[0] = MAGIC[0]; this.prefix[1] = MAGIC[1];
    this.prefix[2] = MAGIC[2]; this.prefix[3] = MAGIC[3];
    this.prefix[4] = (hl >>> 24) & 0xFF;
    this.prefix[5] = (hl >>> 16) & 0xFF;
    this.prefix[6] = (hl >>> 8) & 0xFF;
    this.prefix[7] = hl & 0xFF;
    this.prefix.set(headerBytes, 8);
    this.prefixLen = this.prefix.length;
    this.length = this.prefixLen + fileData.length;
  }
  getFrameSlice(frameIdx) {
    const bpf = EFFECTIVE_BYTES_PER_FRAME;
    const offset = frameIdx * bpf;
    const end = Math.min(offset + bpf, this.length);
    if (end <= offset) return null;
    if (offset >= this.prefixLen) return this.fileData.subarray(offset - this.prefixLen, end - this.prefixLen);
    if (end <= this.prefixLen) return this.prefix.subarray(offset, end);
    const result = new Uint8Array(end - offset);
    result.set(this.prefix.subarray(offset, this.prefixLen));
    result.set(this.fileData.subarray(0, end - this.prefixLen), this.prefixLen - offset);
    return result;
  }
}

function fmtSize(b) {
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
  if (b < 1073741824) return (b / 1048576).toFixed(2) + ' MB';
  return (b / 1073741824).toFixed(2) + ' GB';
}
function fmtTime(sec) {
  if (sec < 60) return Math.round(sec) + 's';
  return Math.floor(sec / 60) + 'm ' + Math.round(sec % 60) + 's';
}

function obfuscateHeader(json) {
  const b = new TextEncoder().encode(json);
  const key = new Uint8Array([0x53,0x48,0x52,0x45,0x4B,0x21,0x4F,0x47,0x52,0x45,0x53,0x57,0x41,0x4D,0x50,0x21]);
  const o = new Uint8Array(b.length);
  for (let i = 0; i < b.length; i++) o[i] = b[i] ^ key[i % key.length];
  return o;
}
function deobfuscateHeader(o) {
  const key = new Uint8Array([0x53,0x48,0x52,0x45,0x4B,0x21,0x4F,0x47,0x52,0x45,0x53,0x57,0x41,0x4D,0x50,0x21]);
  const b = new Uint8Array(o.length);
  for (let i = 0; i < o.length; i++) b[i] = o[i] ^ key[i % key.length];
  return new TextDecoder().decode(b);
}

function estimateOutput(fileSize) {
  const hdrEst = 200;
  const payloadSize = 8 + hdrEst + fileSize;
  const dataFrames = Math.ceil(payloadSize / EFFECTIVE_BYTES_PER_FRAME);
  const totalFrames = Math.max(dataFrames, MIN_FRAMES);
  const duration = totalFrames / FPS;
  return { est: Math.ceil(duration * BITRATE / 8), frames: totalFrames, duration, dataFrames };
}

function updateEstimate() {
  const el = $('estInfo'), warnEl = $('sizeWarn');
  if (!encFile) { el.classList.remove('show'); warnEl.classList.remove('show'); return; }
  const info = estimateOutput(encFile.size);
  $('estText').innerHTML = 'Estimated: <span class="est-val">' + fmtSize(info.est) + '</span> &middot; ' + info.frames + ' frames &middot; ' + fmtTime(info.duration);
  el.classList.add('show');
  if (encFile.size > 25 * 1024 * 1024) {
    warnEl.textContent = 'Large file (' + fmtSize(encFile.size) + '). Encoding will take a long time.';
    warnEl.classList.add('show');
  } else if (encFile.size > 5 * 1024 * 1024) {
    warnEl.textContent = 'File: ' + fmtSize(encFile.size) + '. Encoding may take several minutes.';
    warnEl.classList.add('show');
  } else { warnEl.classList.remove('show'); }
}

async function loadCoverVideo() {
  $('coverDot').className = 'dot loading';
  $('coverText').textContent = 'Loading cover video (Shrek.mp4)...';
  try {
    const v = document.createElement('video');
    v.muted = true; v.playsInline = true; v.crossOrigin = 'anonymous'; v.preload = 'auto';
    v.src = COVER_URL;
    await new Promise((res, rej) => {
      v.onloadedmetadata = res;
      v.onerror = () => rej(new Error('Could not load Shrek.mp4'));
      setTimeout(() => rej(new Error('Timeout')), 15000);
    });
    await new Promise(r => { v.oncanplaythrough = r; v.load(); });
    $('coverDot').className = 'dot ok';
    $('coverText').textContent = 'Cover video ready (' + v.duration.toFixed(1) + 's, ' + v.videoWidth + 'x' + v.videoHeight + ')';
    coverVideoReady = true;
    coverVideo = v;
  } catch (e) {
    $('coverDot').className = 'dot err';
    $('coverText').textContent = 'Cover video failed: ' + e.message + '. Place Shrek.mp4 in same directory.';
    coverVideoReady = false;
  }
}

loadCoverVideo();

function setupDrop(zoneId, inputId, onFile) {
  const zone = $(zoneId), inp = $(inputId);
  zone.addEventListener('click', () => inp.click());
  zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag'); });
  zone.addEventListener('dragleave', () => zone.classList.remove('drag'));
  zone.addEventListener('drop', e => { e.preventDefault(); zone.classList.remove('drag'); if (e.dataTransfer.files[0]) onFile(e.dataTransfer.files[0]); });
  inp.addEventListener('change', () => { if (inp.files[0]) onFile(inp.files[0]); inp.value = ''; });
}
function showStatus(id, type, msg) {
  const el = $(id);
  el.className = 'status show ' + type;
  const icons = { info: '&#9432;', ok: '&#10003;', err: '&#10007;', warn: '&#9888;' };
  el.innerHTML = '<span class="s-icon">' + (icons[type] || '') + '</span><span>' + msg + '</span>';
}
function hideStatus(id) { $(id).className = 'status'; }
function setProgress(barId, pctId, statusId, pct, text) {
  $(barId).style.width = Math.min(100, pct) + '%';
  $(pctId).textContent = Math.round(pct) + '%';
  $(statusId).textContent = text;
}

document.querySelectorAll('.tab').forEach(t => {
  t.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
    document.querySelectorAll('.section').forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    $(t.dataset.tab + 'Section').classList.add('active');
  });
});

function cleanupEncBlob() { if (encBlobUrl) { URL.revokeObjectURL(encBlobUrl); encBlobUrl = null; } encBlob = null; }
function resetEncUI() {
  $('encDlArea').classList.remove('show');
  $('encSpecs').style.display = 'none';
  $('encProgress').classList.remove('show');
  $('encCancelBtn').style.display = 'none';
  hideStatus('encStatusMsg');
  cleanupEncBlob();
}

setupDrop('encDropZone', 'encFileInput', f => {
  encFile = f;
  $('encDropZone').style.display = 'none';
  $('encFileInfo').style.display = 'flex';
  $('encFileName').textContent = f.name;
  $('encFileSize').textContent = fmtSize(f.size);
  $('encodeBtn').disabled = !coverVideoReady;
  resetEncUI();
  updateEstimate();
});

$('encRemoveBtn').addEventListener('click', () => {
  encFile = null;
  $('encDropZone').style.display = '';
  $('encFileInfo').style.display = 'none';
  $('encodeBtn').disabled = true;
  resetEncUI();
  updateEstimate();
});

function generateVideoName() {
  const now = new Date();
  const y = now.getFullYear();
  const mo = String(now.getMonth() + 1).padStart(2, '0');
  const d = String(now.getDate()).padStart(2, '0');
  const h = String(now.getHours()).padStart(2, '0');
  const mi = String(now.getMinutes()).padStart(2, '0');
  return 'shrek_' + y + mo + d + '_' + h + mi + '.mp4';
}

$('encCancelBtn').addEventListener('click', () => { encCancelled = true; });

$('encodeBtn').addEventListener('click', async () => {
  if (!encFile) return;
  const btn = $('encodeBtn');
  btn.disabled = true;
  encCancelled = false;
  resetEncUI();
  $('encProgress').classList.add('show');
  $('encCancelBtn').style.display = '';
  let encoder = null;

  try {
    setProgress('encBar', 'encPercent', 'encStatus', 1, 'Loading cover video...');
    await new Promise(r => setTimeout(r, 0));

    if (!coverVideo || !coverVideoReady) throw new Error('Cover video not loaded. Place Shrek.mp4 in same directory.');
    const shrekDur = coverVideo.duration;

    const cvs = document.createElement('canvas');
    cvs.width = W; cvs.height = H;
    const cctx = cvs.getContext('2d', { willReadFrequently: true });

    setProgress('encBar', 'encPercent', 'encStatus', 3, 'Reading file...');
    await new Promise(r => setTimeout(r, 0));

    const fileData = new Uint8Array(await encFile.arrayBuffer());
    if (encCancelled) throw new Error('Cancelled');

    setProgress('encBar', 'encPercent', 'encStatus', 6, 'Preparing payload...');
    await new Promise(r => setTimeout(r, 0));

    const checksum = crc32(fileData);
    const header = JSON.stringify({
      n: encFile.name,
      s: fileData.length,
      v: 4,
      q: Q,
      r: REDUNDANCY,
      c: checksum,
      w: W,
      h: H,
      b: SBS
    });
    const headerBytes = obfuscateHeader(header);
    const payload = new PayloadView(headerBytes, fileData);
    const dataFrames = Math.ceil(payload.length / EFFECTIVE_BYTES_PER_FRAME);
    const totalFrames = Math.max(dataFrames, MIN_FRAMES);

    $('specFrames').textContent = totalFrames + (totalFrames > dataFrames ? ' (' + dataFrames + ' data + ' + (totalFrames - dataFrames) + ' pad)' : '');
    $('specCapacity').textContent = fmtSize(EFFECTIVE_BYTES_PER_FRAME) + '/frame';
    $('encSpecs').style.display = 'grid';

    setProgress('encBar', 'encPercent', 'encStatus', 8, 'Initializing H.264...');
    await new Promise(r => setTimeout(r, 0));

    const codecString = 'avc1.42001f';
    const support = await VideoEncoder.isConfigSupported({
      codec: codecString, width: W, height: H, bitrate: BITRATE, framerate: FPS,
    });
    if (!support.supported) throw new Error('H.264 not supported in this browser.');

    const muxer = new Muxer({
      target: new ArrayBufferTarget(),
      video: { codec: 'avc', width: W, height: H },
      fastStart: 'in-memory',
    });

    let encError = null;
    encoder = new VideoEncoder({
      output: (chunk, meta) => { muxer.addVideoChunk(chunk, meta); },
      error: e => { encError = e; },
    });

    encoder.configure({
      codec: codecString, width: W, height: H,
      bitrate: BITRATE, framerate: FPS, latencyMode: 'quality',
    });

    const MAX_QUEUE = 8;
    const startTime = performance.now();
    let lastYieldTime = startTime;

    for (let i = 0; i < totalFrames; i++) {
      if (encCancelled) throw new Error('Cancelled');
      if (encError) throw encError;

      const shrekTime = (i / FPS) % shrekDur;
      coverVideo.currentTime = shrekTime;
      await new Promise(r => { coverVideo.addEventListener('seeked', r, { once: true }); });

      cctx.drawImage(coverVideo, 0, 0, W, H);
      const imgData = cctx.getImageData(0, 0, W, H);

      const slice = payload.getFrameSlice(i);
      embedFrame(imgData, slice);

      cctx.putImageData(imgData, 0, 0);

      const frame = new VideoFrame(cvs, {
        timestamp: i * (1_000_000 / FPS),
        duration: 1_000_000 / FPS,
      });

      while (encoder.encodeQueueSize >= MAX_QUEUE) {
        await new Promise(resolve => { encoder.addEventListener('dequeue', resolve, { once: true }); });
        if (encCancelled) { frame.close(); throw new Error('Cancelled'); }
        if (encError) { frame.close(); throw encError; }
      }

      encoder.encode(frame, { keyFrame: true });
      frame.close();

      const now = performance.now();
      if (now - lastYieldTime > 30 || i === totalFrames - 1) {
        const pct = 10 + (i / totalFrames) * 85;
        const elapsed = (now - startTime) / 1000;
        const fps = (i + 1) / elapsed;
        const remaining = (totalFrames - i - 1) / fps;
        const etaStr = i > 10 ? ' (ETA: ' + fmtTime(remaining) + ')' : '';
        setProgress('encBar', 'encPercent', 'encStatus', pct, 'Frame ' + (i + 1) + '/' + totalFrames + etaStr);
        await new Promise(r => setTimeout(r, 0));
        lastYieldTime = performance.now();
      }
    }

    setProgress('encBar', 'encPercent', 'encStatus', 96, 'Flushing encoder...');
    await new Promise(r => setTimeout(r, 0));

    await encoder.flush();
    encoder.close();
    encoder = null;
    muxer.finalize();

    if (encError) throw encError;

    const mp4Buf = muxer.target.buffer;
    encBlob = new Blob([mp4Buf], { type: 'video/mp4' });

    setProgress('encBar', 'encPercent', 'encStatus', 100, 'Done!');
    showStatus('encStatusMsg', 'ok',
      'Data hidden in the swamp! ' + totalFrames + ' frames, ' + (totalFrames / FPS).toFixed(1) + 's, ' + fmtSize(mp4Buf.byteLength) + '. Video looks normal. CRC32: ' + checksum.toString(16).toUpperCase());
    $('encDlArea').classList.add('show');

  } catch (e) {
    if (encoder) { try { encoder.close(); } catch (_) { } }
    if (e.message === 'Cancelled') {
      showStatus('encStatusMsg', 'warn', 'Encoding cancelled.');
    } else {
      console.error(e);
      showStatus('encStatusMsg', 'err', 'Encoding failed: ' + e.message);
    }
  }
  btn.disabled = false;
  $('encCancelBtn').style.display = 'none';
});

$('encDlBtn').addEventListener('click', () => {
  if (!encBlob) return;
  if (encBlobUrl) URL.revokeObjectURL(encBlobUrl);
  encBlobUrl = URL.createObjectURL(encBlob);
  const a = document.createElement('a');
  a.href = encBlobUrl; a.download = generateVideoName();
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
});

function cleanupDecBlob() { if (decBlobUrl) { URL.revokeObjectURL(decBlobUrl); decBlobUrl = null; } decResult = null; }

setupDrop('decDropZone', 'decFileInput', f => {
  decFile = f;
  $('decDropZone').style.display = 'none';
  $('decFileInfo').style.display = 'flex';
  $('decFileName').textContent = f.name;
  $('decFileSize').textContent = fmtSize(f.size);
  $('decodeBtn').disabled = false;
  $('decDlArea').classList.remove('show');
  $('decProgress').classList.remove('show');
  $('decCancelBtn').style.display = 'none';
  hideStatus('decStatusMsg');
  cleanupDecBlob();
});

$('decRemoveBtn').addEventListener('click', () => {
  decFile = null;
  $('decDropZone').style.display = '';
  $('decFileInfo').style.display = 'none';
  $('decodeBtn').disabled = true;
  $('decDlArea').classList.remove('show');
  $('decProgress').classList.remove('show');
  $('decCancelBtn').style.display = 'none';
  hideStatus('decStatusMsg');
  cleanupDecBlob();
});

$('decCancelBtn').addEventListener('click', () => { decCancelled = true; });

$('decodeBtn').addEventListener('click', async () => {
  if (!decFile) return;
  const btn = $('decodeBtn');
  btn.disabled = true;
  decCancelled = false;
  $('decCancelBtn').style.display = '';
  $('decProgress').classList.add('show');
  $('decDlArea').classList.remove('show');
  hideStatus('decStatusMsg');
  cleanupDecBlob();

  let videoUrl = null;

  try {
    setProgress('decBar', 'decPercent', 'decStatus', 1, 'Loading video...');
    await new Promise(r => setTimeout(r, 0));

    const video = document.createElement('video');
    video.muted = true; video.playsInline = true; video.preload = 'auto';
    videoUrl = URL.createObjectURL(decFile);
    video.src = videoUrl;

    await new Promise((res, rej) => {
      video.onloadedmetadata = res;
      video.onerror = () => rej(new Error('Failed to load video.'));
    });
    await new Promise(r => { video.oncanplaythrough = r; video.load(); });

    const canvas = document.createElement('canvas');
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const estFrames = Math.max(1, Math.round(video.duration * FPS));
    setProgress('decBar', 'decPercent', 'decStatus', 3, 'Extracting from ' + estFrames + ' frames...');

    let outputBuffer = null;
    let outputOffset = 0;
    let headerParsed = false;
    let totalNeeded = 0;
    let parsedHeader = null;
    const maxTempSize = Math.min(estFrames * EFFECTIVE_BYTES_PER_FRAME, 500000);
    const tempBuffer = new Uint8Array(maxTempSize);
    let tempOffset = 0;

    const startTime = performance.now();
    let lastYieldTime = startTime;

    for (let i = 0; i < estFrames; i++) {
      if (decCancelled) throw new Error('Cancelled');

      const t = i / FPS;
      if (t > video.duration + 0.5) break;

      video.currentTime = t;
      await new Promise(r => { video.addEventListener('seeked', r, { once: true }); });

      ctx.drawImage(video, 0, 0, W, H);
      const imgData = ctx.getImageData(0, 0, W, H);
      const frameBytes = extractFrame(imgData);

      if (!headerParsed) {
        const copyLen = Math.min(EFFECTIVE_BYTES_PER_FRAME, tempBuffer.length - tempOffset);
        if (copyLen > 0) { tempBuffer.set(frameBytes.subarray(0, copyLen), tempOffset); tempOffset += copyLen; }

        if (tempOffset >= 8) {
          if (tempBuffer[0] !== MAGIC[0] || tempBuffer[1] !== MAGIC[1] ||
            tempBuffer[2] !== MAGIC[2] || tempBuffer[3] !== MAGIC[3]) {
            throw new Error('No hidden data found. This video was not created by SwampCrypt.');
          }
          const hl = (tempBuffer[4] << 24) | (tempBuffer[5] << 16) | (tempBuffer[6] << 8) | tempBuffer[7];
          if (hl > 10000 || hl < 10) throw new Error('Invalid header (' + hl + '). Video may be corrupted.');

          if (tempOffset >= 8 + hl) {
            try {
              const hdrJson = deobfuscateHeader(tempBuffer.slice(8, 8 + hl));
              parsedHeader = JSON.parse(hdrJson);
              if (!parsedHeader.n || !parsedHeader.s) throw new Error('Invalid header');
              parsedHeader.name = parsedHeader.n;
              parsedHeader.size = parsedHeader.s;
              totalNeeded = 8 + hl + parsedHeader.size;
              outputBuffer = new Uint8Array(totalNeeded);
              const toCopy = Math.min(tempOffset, totalNeeded);
              outputBuffer.set(tempBuffer.subarray(0, toCopy));
              outputOffset = toCopy;
              headerParsed = true;
            } catch (e) {
              throw new Error('Failed to parse header: ' + e.message);
            }
          }
        }
      } else {
        const remaining = totalNeeded - outputOffset;
        if (remaining > 0) {
          const toCopy = Math.min(EFFECTIVE_BYTES_PER_FRAME, remaining);
          outputBuffer.set(frameBytes.subarray(0, toCopy), outputOffset);
          outputOffset += toCopy;
        }
        if (outputOffset >= totalNeeded) {
          setProgress('decBar', 'decPercent', 'decStatus', 90, 'All data extracted.');
          break;
        }
      }

      const now = performance.now();
      if (now - lastYieldTime > 50 || i === estFrames - 1) {
        const pct = 5 + ((i + 1) / estFrames) * 80;
        const elapsed = (now - startTime) / 1000;
        const fps = (i + 1) / elapsed;
        const framesLeft = headerParsed ? Math.ceil((totalNeeded - outputOffset) / EFFECTIVE_BYTES_PER_FRAME) : (estFrames - i - 1);
        const etaStr = i > 3 ? ' (ETA: ' + fmtTime(framesLeft / fps) + ')' : '';
        setProgress('decBar', 'decPercent', 'decStatus', pct, 'Frame ' + (i + 1) + '/' + estFrames + etaStr);
        await new Promise(r => setTimeout(r, 0));
        lastYieldTime = performance.now();
      }
    }

    if (videoUrl) { URL.revokeObjectURL(videoUrl); videoUrl = null; }

    if (!headerParsed) throw new Error('No hidden data found. Use a video created by SwampCrypt v3+.');
    if (outputOffset < totalNeeded) throw new Error('Incomplete data. Expected ' + totalNeeded + ' bytes, got ' + outputOffset + '.');

    setProgress('decBar', 'decPercent', 'decStatus', 95, 'Verifying integrity...');
    await new Promise(r => setTimeout(r, 0));

    const hl = (outputBuffer[4] << 24) | (outputBuffer[5] << 16) | (outputBuffer[6] << 8) | outputBuffer[7];
    const fileData = outputBuffer.slice(8 + hl, 8 + hl + parsedHeader.size);

    let integrityMsg = '';
    if (parsedHeader.c !== undefined) {
      const extractedCrc = crc32(fileData);
      if (extractedCrc === parsedHeader.c) {
        integrityMsg = ' CRC32 verified OK.';
      } else {
        integrityMsg = ' WARNING: CRC32 mismatch (expected ' + parsedHeader.c.toString(16).toUpperCase() + ', got ' + extractedCrc.toString(16).toUpperCase() + '). File may have minor corruption from video compression.';
      }
    }

    setProgress('decBar', 'decPercent', 'decStatus', 100, 'Done!');
    showStatus('decStatusMsg', 'ok', 'File "' + parsedHeader.name + '" (' + fmtSize(parsedHeader.size) + ') extracted from the swamp!' + integrityMsg);

    decResult = { data: fileData, filename: parsedHeader.name };
    $('decDlArea').classList.add('show');

  } catch (e) {
    if (videoUrl) { URL.revokeObjectURL(videoUrl); videoUrl = null; }
    if (e.message === 'Cancelled') {
      showStatus('decStatusMsg', 'warn', 'Decoding cancelled.');
    } else {
      console.error(e);
      showStatus('decStatusMsg', 'err', e.message);
    }
  }
  btn.disabled = false;
  $('decCancelBtn').style.display = 'none';
});

$('decDlBtn').addEventListener('click', () => {
  if (!decResult) return;
  if (decBlobUrl) URL.revokeObjectURL(decBlobUrl);
  const blob = new Blob([decResult.data]);
  decBlobUrl = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = decBlobUrl; a.download = decResult.filename;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
});
</script>
</body>
</html>
